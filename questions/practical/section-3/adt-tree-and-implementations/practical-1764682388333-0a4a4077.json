{
  "id": "practical-1764682388333-0a4a4077",
  "title": "List of Children Tree",
  "description": "The List of Children representation of a tree is described by an array of linked list where the indices are parents and the nodes are children",
  "difficulty": "Medium",
  "section": "Section 3",
  "lesson": "ADT Tree and Implementations",
  "author": "suchxs",
  "files": [
    {
      "filename": "main.c",
      "content": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include \"tree.h\"\n\n\n\n/**\n * @brief Frees the memory allocated for the children linked lists.\n * @param T Pointer to the Tree structure.\n */\nvoid freeTree(Tree *T) {\n    for (int i = 0; i < MAX_NODES; i++) {\n        ChildNode *current = T->children[i];\n        ChildNode *next;\n        while (current != NULL) {\n            next = current->next;\n            free(current);\n            current = next;\n        }\n        T->children[i] = NULL; // Reset pointer to NULL after freeing\n    }\n    printf(\"\\nTree memory cleaned up.\\n\");\n}\n\n\n// --- Demonstration and Utility ---\n\n/**\n * @brief Prints the contents of the tree array representation.\n * @param T Pointer to the Tree structure.\n */\nvoid printTree(const Tree *T) {\n    printf(\"--- Tree Children List Representation ---\\n\");\n    printf(\"Root Index: %d\\n\", T->rootIndex);\n    printf(\"Parent Index | Children List\\n\");\n    printf(\"-------------|---------------\\n\");\n\n    for (int i = 0; i < MAX_NODES; i++) {\n        printf(\"%12d | \", i);\n        ChildNode *current = T->children[i];\n        if (current == NULL) {\n            printf(\"(None)\\n\");\n        } else {\n            while (current != NULL) {\n                printf(\"%d -> \", current->childIndex);\n                current = current->next;\n            }\n            printf(\"NULL\\n\");\n        }\n    }\n    printf(\"-----------------------------------------\\n\");\n}\n\n\nint main() {\n    Tree myTree;\n    initializeTree(&myTree);\n\n\n    makeRoot(&myTree, 0);       // 0 is the root\n\n    // Add children to 0\n    addChild(&myTree, 0, 1);\n    addChild(&myTree, 0, 2);\n\n    // Add children to 1\n    addChild(&myTree, 1, 3);\n    addChild(&myTree, 1, 4);\n\n    // Add children to 2\n    addChild(&myTree, 2, 5);\n\n    // Add children to 5\n    addChild(&myTree, 5, 8);\n    addChild(&myTree, 5, 9);\n    // Node indices 3, 4, 8, 9 are the leaves.\n    // Leftmost leaf (smallest index) is 3.\n    // Rightmost leaf (largest index) is 9.\n\n    printTree(&myTree);\n\n    // --- Testing Operations ---\n    printf(\"\\n--- Testing ADT Operations ---\\n\");\n\n    // 1. Test parent()\n    Node node_to_check = 5;\n    Node p = parent(node_to_check, &myTree);\n    if (p == ROOT_NODE) {\n        printf(\"Parent of Node %d: (It is the Root)\\n\", node_to_check);\n    } else if (p == INVALID_NODE) {\n        printf(\"Parent of Node %d: (Node is Invalid/Not Found)\\n\", node_to_check);\n    } else {\n        printf(\"Parent of Node %d: Node %d\\n\", node_to_check, p); // Expected: 2\n    }\n\n    node_to_check = 0; // The Root\n    p = parent(node_to_check, &myTree);\n    if (p == ROOT_NODE) {\n        printf(\"Parent of Node %d: (It is the Root)\\n\", node_to_check); // Expected: ROOT_NODE\n    } else {\n        printf(\"Parent of Node %d: Node %d\\n\", node_to_check, p);\n    }\n\n    node_to_check = 7; // Not in tree\n    p = parent(node_to_check, &myTree);\n    if (p == INVALID_NODE) {\n        printf(\"Parent of Node %d: (Node is Invalid/Not Found)\\n\", node_to_check); // Expected: INVALID_NODE\n    } else {\n        printf(\"Parent of Node %d: Node %d\\n\", node_to_check, p);\n    }\n\n\n    // 2. Test left() - leftmost leaf (smallest index leaf)\n    Node l = left(&myTree);\n    if (l != INVALID_NODE) {\n        printf(\"Leftmost Leaf: Node %d\\n\", l); // Expected: 3\n    } else {\n        printf(\"Leftmost Leaf: Tree is empty or has no leaves.\\n\");\n    }\n\n    // 3. Test right() - rightmost leaf (largest index leaf)\n    Node r = right(&myTree);\n    if (r != INVALID_NODE) {\n        printf(\"Rightmost Leaf: Node %d\\n\", r); // Expected: 9\n    } else {\n        printf(\"Rightmost Leaf: Tree is empty or has no leaves.\\n\");\n    }\n\n    // Clean up memory\n    freeTree(&myTree);\n\n    return 0;\n}",
      "is_locked": true,
      "is_answer_file": false,
      "language": "c"
    },
    {
      "filename": "tree.c",
      "content": "#include \"tree.h\"\n\n\n\n\n/**\n * @brief Initializes the Tree structure.\n * Sets the root index to INVALID_NODE and all children list heads to NULL.\n * @param T Pointer to the Tree structure to initialize.\n */\nvoid initializeTree(Tree *T) {\n    T->rootIndex = INVALID_NODE;\n    \n    for (int i = 0; i < MAX_NODES; i++){\n        T->children[i] = NULL;\n    }\n}\n\n/**\n * @brief Designates a node as the root.\n * @param T Pointer to the Tree structure.\n * @param r The index of the node to be set as root.\n */\nvoid makeRoot(Tree *T, Node r) {\n    T->rootIndex = r;\n}\n\n/**\n * @brief Adds a new child node to the parent's linked list.\n * @param T Pointer to the Tree structure.\n * @param parent_index The index of the parent node (array index).\n * @param child_index The index of the child node (value in the linked list).\n */\nvoid addChild(Tree *T, Node parent_index, Node child_index) {\n    ChildNode *newNode = (ChildNode *)malloc(sizeof(ChildNode));\n    \n    if (newNode == NULL){\n        printf(\"Memory allocation failed!\\n\");\n        return;\n    }\n    \n    newNode->childIndex = child_index;\n    newNode->next = T->children[parent_index];\n    T->children[parent_index] = newNode;\n}\n\n\n/**\n * @brief Returns the parent of a given node.\n * Requires searching through all parent lists to find the node.\n * @param n The node index (child).\n * @param T Pointer to the Tree structure.\n * @return The parent node index, ROOT_NODE if n is the root, or INVALID_NODE if n is invalid/uninitialized.\n */\nNode parent(Node n, const Tree *T) {\n    if (T->rootIndex == n && T->rootIndex != INVALID_NODE){\n        return ROOT_NODE;\n    }\n    \n    for (int i = 0; i < MAX_NODES; i++){\n        ChildNode *curr = T->children[i];\n        \n        while (curr != NULL){\n            if (curr->childIndex == n){\n                return i; // Ts is parent lol\n            }\n            curr = curr->next;\n        }\n    }\n\n    \n    return INVALID_NODE;\n}\n\n/**\n * @brief Returns the leftmost leaf element (the leaf node with the smallest index) in the tree.\n * @param T Pointer to the Tree structure.\n * @return The index of the leftmost leaf, or INVALID_NODE if the tree is empty or has no leaves.\n */\nNode left(const Tree *T) {\n    for (int i = 0; i < MAX_NODES; i++){\n        \n        if (T->children[i] == NULL){\n            if (i == T->rootIndex || parent(i, T) != INVALID_NODE){\n                return i;\n            }\n        }\n    }\n    \n    return INVALID_NODE;\n}\n\n/**\n * @brief Returns the rightmost leaf element (the leaf node with the largest index) in the tree.\n * @param T Pointer to the Tree structure.\n * @return The index of the rightmost leaf, or INVALID_NODE if the tree is empty or has no leaves.\n */\nNode right(const Tree *T) {\n    for (int i = MAX_NODES - 1; i >= 0; i--){\n        if (T->children[i] == NULL){\n            if (i == T->rootIndex || parent(i, T) != INVALID_NODE){\n                return i;\n            }\n        }\n    }\n    \n    \n    return INVALID_NODE;\n}\n",
      "is_locked": false,
      "is_answer_file": true,
      "language": "c"
    },
    {
      "filename": "tree.h",
      "content": "#ifndef TREE_H\n#define TREE_H\n\n// Your header declarations here\n\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\n\n#define MAX_NODES 10\n#define ROOT_NODE -1\n#define INVALID_NODE -2\n\n// Type definition for a node index\ntypedef int Node;\n\n// 1. Linked List Node Definition\n// Each node in the linked list represents a child of the parent (array index)\ntypedef struct ChildNode {\n    Node childIndex;\n    struct ChildNode *next;\n} ChildNode;\n\n// 2. Tree Structure Definition\n// The Tree holds the root index and an array of head pointers for the children lists.\ntypedef struct {\n    Node rootIndex;\n    // Array of heads of linked lists.\n    // children[i] points to the first child of node i.\n    ChildNode* children[MAX_NODES];\n} Tree;\n\n\nvoid initializeTree(Tree *T);\nvoid makeRoot(Tree *T, Node r);\nvoid addChild(Tree *T, Node parent_index, Node child_index);\nNode parent(Node n, const Tree *T);\nNode left(const Tree *T);\nNode right(const Tree *T);\n\n#endif // TREE_H\n",
      "is_locked": true,
      "is_answer_file": false,
      "language": "c"
    }
  ],
  "test_cases": [
    {
      "input": "",
      "expected_output": "--- Tree Children List Representation ---\r\nRoot Index: 0\r\nParent Index | Children List\r\n-------------|---------------\r\n           0 | 2 -> 1 -> NULL\r\n           1 | 4 -> 3 -> NULL\r\n           2 | 5 -> NULL\r\n           3 | (None)\r\n           4 | (None)\r\n           5 | 9 -> 8 -> NULL\r\n           6 | (None)\r\n           7 | (None)\r\n           8 | (None)\r\n           9 | (None)\r\n-----------------------------------------\r\n\r\n--- Testing ADT Operations ---\r\nParent of Node 5: Node 2\r\nParent of Node 0: (It is the Root)\r\nParent of Node 7: (Node is Invalid/Not Found)\r\nLeftmost Leaf: Node 3\r\nRightmost Leaf: Node 9\r\n\r\nTree memory cleaned up.",
      "is_hidden": false,
      "execution_time": 446,
      "memory_usage": 0
    },
    {
      "input": "",
      "expected_output": "--- Tree Children List Representation ---\r\nRoot Index: 0\r\nParent Index | Children List\r\n-------------|---------------\r\n           0 | 2 -> 1 -> NULL\r\n           1 | 4 -> 3 -> NULL\r\n           2 | 5 -> NULL\r\n           3 | (None)\r\n           4 | (None)\r\n           5 | 9 -> 8 -> NULL\r\n           6 | (None)\r\n           7 | (None)\r\n           8 | (None)\r\n           9 | (None)\r\n-----------------------------------------\r\n\r\n--- Testing ADT Operations ---\r\nParent of Node 5: Node 2\r\nParent of Node 0: (It is the Root)\r\nParent of Node 7: (Node is Invalid/Not Found)\r\nLeftmost Leaf: Node 3\r\nRightmost Leaf: Node 9\r\n\r\nTree memory cleaned up.",
      "is_hidden": false,
      "execution_time": 516,
      "memory_usage": 0
    },
    {
      "input": "",
      "expected_output": "--- Tree Children List Representation ---\r\nRoot Index: 0\r\nParent Index | Children List\r\n-------------|---------------\r\n           0 | 2 -> 1 -> NULL\r\n           1 | 4 -> 3 -> NULL\r\n           2 | 5 -> NULL\r\n           3 | (None)\r\n           4 | (None)\r\n           5 | 9 -> 8 -> NULL\r\n           6 | (None)\r\n           7 | (None)\r\n           8 | (None)\r\n           9 | (None)\r\n-----------------------------------------\r\n\r\n--- Testing ADT Operations ---\r\nParent of Node 5: Node 2\r\nParent of Node 0: (It is the Root)\r\nParent of Node 7: (Node is Invalid/Not Found)\r\nLeftmost Leaf: Node 3\r\nRightmost Leaf: Node 9\r\n\r\nTree memory cleaned up.",
      "is_hidden": false,
      "execution_time": 442,
      "memory_usage": 0
    }
  ],
  "created_at": "2025-12-02T13:33:08.331Z",
  "updated_at": "2025-12-02T13:33:08.331Z",
  "image": "practical-1764682388333-0a4a4077-0.png"
}